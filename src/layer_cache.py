from google.appengine.api import memcache
from globals import Globals
import logging
import cachepy

# layer_cache provides an easy way to cache the result of functions in
# both memcache and cachepy's storage for quick retrieval later.
#
#
#
# _____Explanation by examples:_____
#
# Cache in both memcache and cachepy the result of
# this long-running function using a static key,
# and return the result when available instead of recalculating:
#
# @cache_with_key("calculate_user_averages")
# def calculate_user_averages:
#    ...do lots of long-running work...
#
#
#
# and with expiration every minute:
#
# @cache_with_key("calculate_user_averages", expiration=60)
# def calculate_user_averages:
#    ...do lots of long-running work...
#
#
#
# Cache using key generated by utility function that
# varies the key based on the function's input parameters:
#
# @cache_with_key_function(lambda object: return "layer_cache_key_for_object_%s" % object.id())
# def calculate_object_average(object):
#   ... do lots of long-running work...
#
#
#
# _____Manually busting the cache:_____
#
# When you call your cached function, just pass a special "bust_cache"
# named parameter to ignore any existing cached values and replace
# with whatever is newly returned:
#
# calculate_object_average(object, bust_cache=True)
#
#
#
# _____Other settings/options:_____
#
# Only cache in memcache, not cachepy's in-app memory cache:
# @cache_with_key(... layer=SINGLE_LAYER_MEMCACHE_ONLY)
#
# Only cache in cachepy's in-app memory cache, not memcache:
# @cache_with_key(... layer=SINGLE_LAYER_IN_APP_MEMORY_CACHE_ONLY)
#
# Persist the cached values across different uploaded app verions
# (by default this will not happen w/ memcache):
# @cache_with_key(... persist_across_app_versions=True)


def cache(layer=None, expiration=None, bust_cache=None):
    def decorator(target):
        def wrapper(*args, **kwargs):
            return layer_cache_check_set_return(target, layer, expiration,
                                                bust_cache, *args, **kwargs)

        return wrapper

    return decorator


def layer_cache_check_set_return(target, d_layer, d_expiration, d_bust_cache,
                                 *args, **kwargs):

    key = kwargs.get("key", "")
    if d_layer is None:
        layer = kwargs.get("layer",
                           Globals.DUAL_LAYER_MEMCACHE_AND_IN_APP_MEMORY_CACHE)
    else:
        layer = d_layer
    if d_expiration is None:
        expiration = kwargs.get("expiration", Globals._1_WEEK)
    else:
        expiration = d_expiration
    if d_bust_cache is None:
        bust_cache = kwargs.get("bust_cache", False)
    else:
        bust_cache = d_bust_cache

    #logging.info("read key: %s, layer: %s, bust_cache: %s, expiration: %s", key, layer, bust_cache, expiration)

    if not bust_cache:
        if layer != Globals.SINGLE_LAYER_MEMCACHE_ONLY:
            result = cachepy.get(key)
            if result is not None:
                return result

        if layer != Globals.SINGLE_LAYER_IN_APP_MEMORY_CACHE_ONLY:
            result = memcache.Client().get(key)
            if result is not None:
                cachepy.set(key, result)
                return result

    result = target(*args, **kwargs)

    # In case the key's value has been changed by target's execution
    key = kwargs.get("key", "")

    #logging.info("write key: %s, layer: %s, bust_cache: %s, expiration: %s", key, layer, bust_cache, expiration)

    if layer != Globals.SINGLE_LAYER_MEMCACHE_ONLY:
        cachepy.set(key, result, expiry=expiration)

    if layer != Globals.SINGLE_LAYER_IN_APP_MEMORY_CACHE_ONLY:
        if not memcache.Client().set(key, result, time=expiration):
            logging.error("Memcache set failed for %s" % key)

    return result
